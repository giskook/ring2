// Code generated by protoc-gen-go.
// source: distribute_ack.proto
// DO NOT EDIT!

package Carrier

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// enum 的名称必须和协议里的字段相同，虽然耦合，但是少些好多代码 ;P
type DistributeAck_AckType int32

const (
	DistributeAck_TMSREAD DistributeAck_AckType = 0
)

var DistributeAck_AckType_name = map[int32]string{
	0: "TMSREAD",
}
var DistributeAck_AckType_value = map[string]int32{
	"TMSREAD": 0,
}

func (x DistributeAck_AckType) String() string {
	return proto.EnumName(DistributeAck_AckType_name, int32(x))
}
func (DistributeAck_AckType) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{0, 0} }

type DistributeAck struct {
	// 确认类型 目前默认为0,仅支持已读消息的确认
	Type DistributeAck_AckType `protobuf:"varint,1,opt,name=type,enum=Carrier.DistributeAck_AckType" json:"type,omitempty"`
	// imei
	Imei string `protobuf:"bytes,2,opt,name=imei" json:"imei,omitempty"`
	// 时间 格式为YYMMDD-HHMMSS  终端已读协议上报的时间
	Time string `protobuf:"bytes,3,opt,name=time" json:"time,omitempty"`
}

func (m *DistributeAck) Reset()                    { *m = DistributeAck{} }
func (m *DistributeAck) String() string            { return proto.CompactTextString(m) }
func (*DistributeAck) ProtoMessage()               {}
func (*DistributeAck) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *DistributeAck) GetType() DistributeAck_AckType {
	if m != nil {
		return m.Type
	}
	return DistributeAck_TMSREAD
}

func (m *DistributeAck) GetImei() string {
	if m != nil {
		return m.Imei
	}
	return ""
}

func (m *DistributeAck) GetTime() string {
	if m != nil {
		return m.Time
	}
	return ""
}

func init() {
	proto.RegisterType((*DistributeAck)(nil), "Carrier.DistributeAck")
	proto.RegisterEnum("Carrier.DistributeAck_AckType", DistributeAck_AckType_name, DistributeAck_AckType_value)
}

func init() { proto.RegisterFile("distribute_ack.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 142 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xe2, 0x12, 0x49, 0xc9, 0x2c, 0x2e,
	0x29, 0xca, 0x4c, 0x2a, 0x2d, 0x49, 0x8d, 0x4f, 0x4c, 0xce, 0xd6, 0x2b, 0x28, 0xca, 0x2f, 0xc9,
	0x17, 0x62, 0x77, 0x4e, 0x2c, 0x2a, 0xca, 0x4c, 0x2d, 0x52, 0x2a, 0xe4, 0xe2, 0x75, 0x81, 0x2b,
	0x70, 0x4c, 0xce, 0x16, 0xd2, 0xe1, 0x62, 0x29, 0xa9, 0x2c, 0x48, 0x95, 0x60, 0x54, 0x60, 0xd4,
	0xe0, 0x33, 0x92, 0xd3, 0x83, 0x2a, 0xd4, 0x43, 0x51, 0xa5, 0xe7, 0x98, 0x9c, 0x1d, 0x52, 0x59,
	0x90, 0x2a, 0xc4, 0xc3, 0xc5, 0x92, 0x99, 0x9b, 0x9a, 0x29, 0xc1, 0xa4, 0xc0, 0xa8, 0xc1, 0x09,
	0xe2, 0x95, 0x64, 0xe6, 0xa6, 0x4a, 0x30, 0x83, 0x78, 0x4a, 0x62, 0x5c, 0xec, 0x30, 0x65, 0xdc,
	0x5c, 0xec, 0x21, 0xbe, 0xc1, 0x41, 0xae, 0x8e, 0x2e, 0x02, 0x0c, 0x49, 0x6c, 0x60, 0x27, 0x18,
	0x03, 0x02, 0x00, 0x00, 0xff, 0xff, 0x18, 0x3a, 0x82, 0x2b, 0x9a, 0x00, 0x00, 0x00,
}
